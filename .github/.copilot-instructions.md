<!--
SPDX-FileCopyrightText: 2026 Michael Fisher <mfisher@lvtk.org>
SPDX-License-Identifier: ISC
-->

# LUI Development Guidelines

> **Note**: For detailed technical documentation, see `.claude/skills/` directory

## Architecture Overview

LUI is a lightweight UI library for audio plugins with three main layers:

1. **Core Library** (`include/lui/`, `src/ui/`) - Backend-agnostic abstractions
   - `Path` - JUCE-style path representation with safety guards (e.g., auto move_to(0,0))
   - `Graphics` - High-level drawing API
   - `DrawingContext` - Backend interface

2. **Backend Implementation** (`src/ui/nanovg.cpp`, `src/ui/nanovg.hpp`)
   - NanoVG OpenGL renderer
   - Context-specific behavior (e.g., nvgMoveTo creates new sub-paths)

3. **Widgets** (`src/ui/*.cpp`) - UI components using the abstractions

## Debugging Philosophy

### Where to Look First

When tracking down rendering bugs:

1. **Start at the backend** - Backend-specific quirks often cause issues
   - Example: NanoVG's `nvgMoveTo` creates a new sub-path (not documented clearly)
   - Check how native backend functions behave vs. our abstractions

2. **Check the adapter layer** - How abstractions map to backend calls
   - Look at `Graphics::fill_path()` → `Context::fill()` flow
   - Backend state tracking (e.g., `has_geometry` flag)

3. **Question assumptions** - Core library design may be JUCE-compatible but backend-incompatible
   - Example: Path's defensive `move_to(0,0)` is fine for JUCE, problematic for NanoVG

### What NOT to Change

**DO NOT modify core library classes without deep analysis:**

- ❌ Don't remove safety features from `Path` (e.g., auto move_to checks)
- ❌ Don't change `Graphics` high-level API to work around backend issues
- ❌ Don't alter widget paint logic to compensate for rendering bugs

**DO fix issues at the right layer:**

- ✅ Add backend-specific handling in `nanovg.cpp` 
- ✅ Track backend state to filter problematic operations
- ✅ Document backend quirks in comments

## Common Pitfalls

### NanoVG Specifics

- Every `nvgMoveTo` creates a NEW sub-path (even after `nvgBeginPath`)
- Multiple sub-paths can interfere with fills (empty paths cause artifacts)
- `nvgPathWinding(NVG_SOLID)` enforces CCW winding via non-zero fill rule
- Winding matters: CW vs CCW affects fill behavior

### Path System

- `Path` intentionally adds `move_to(0,0)` when `line_to`/`cubic_to` called on empty path
- This is JUCE-compatible behavior and should NOT be removed
- Backend must handle or filter these operations appropriately

## Testing Strategy

- Currently tested: **macOS only**
- Test all path operations: fill, stroke, clipping
- Verify shapes: rectangles, ellipses, triangles, complex paths
- Check widget rendering: dials, sliders, buttons
- Cross-platform testing needed: Windows, Linux

## When Adding Features

1. Keep backend-agnostic abstractions clean
2. Implement backend-specific details in `nanovg.cpp`
3. Document any backend quirks discovered
4. Test with multiple shape types
5. Verify dials demo renders correctly (sensitive to path bugs)
